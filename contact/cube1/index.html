<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VMSD.in Interactive Cube</title>
    <style>
        /* Basic CSS to make the canvas fill the screen */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            font-family: 'Inter', sans-serif;
            color: white;
            display: flex;
            justify-content: center;
            align-items: flex-end;
        }
        #container {
            width: 100%;
            height: 100%;
        }
        .info {
            position: absolute;
            bottom: 20px;
            padding: 10px;
            text-align: center;
            font-size: 14px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 8px;
        }
    </style>
    <!-- Google Fonts for a modern look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="container"></div>

    <!-- Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for camera interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Scene Setup ---
        let scene, camera, renderer, cube, controls;

        function init() {
            // Get the container element
            const container = document.getElementById('container');

            // Create the scene
            scene = new THREE.Scene();

            // Create the camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3.5;

            // Create the renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(2, 3, 4);
            scene.add(directionalLight);

            // --- Texture Creation ---
            function createTexture(drawFunction) {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const context = canvas.getContext('2d');
                drawFunction(context, canvas.width, canvas.height);
                return new THREE.CanvasTexture(canvas);
            }

            // Right Side: Visual Merchandising (VM)
            const vmTexture = createTexture((ctx, w, h) => {
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 8;

                // Simple mannequin
                ctx.beginPath();
                ctx.arc(w * 0.5, h * 0.3, 40, 0, Math.PI * 2); // Head
                ctx.moveTo(w * 0.5, h * 0.3 + 40);
                ctx.lineTo(w * 0.5, h * 0.65); // Body
                ctx.moveTo(w * 0.35, h * 0.45);
                ctx.lineTo(w * 0.65, h * 0.45); // Arms
                ctx.moveTo(w * 0.5, h * 0.65);
                ctx.lineTo(w * 0.4, h * 0.85); // Left Leg
                ctx.moveTo(w * 0.5, h * 0.65);
                ctx.lineTo(w * 0.6, h * 0.85); // Right Leg
                ctx.stroke();

                // Simple shelf
                ctx.strokeRect(w * 0.15, h * 0.5, 100, 200);
                ctx.beginPath();
                ctx.moveTo(w * 0.15, h * 0.65);
                ctx.lineTo(w*0.15 + 100, h * 0.65);
                ctx.stroke();

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 60px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('VISUAL', w / 2, h * 0.1);
                ctx.fillText('MERCHANDISING', w / 2, h * 0.18);
            });

            // Left Side: Store Design (SD)
            const sdTexture = createTexture((ctx, w, h) => {
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = '#ff0055';
                ctx.lineWidth = 6;

                // Blueprint grid
                ctx.globalAlpha = 0.3;
                for (let i = 0; i < w; i += 40) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(w, i);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1.0;

                // Layout lines
                ctx.lineWidth = 12;
                ctx.strokeRect(w * 0.15, h * 0.25, w * 0.7, h * 0.6);
                ctx.strokeRect(w * 0.15, h * 0.25, w * 0.3, h * 0.2);
                ctx.strokeRect(w * 0.6, h * 0.5, w * 0.25, h * 0.35);


                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 70px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('STORE', w / 2, h * 0.1);
                ctx.fillText('DESIGN', w / 2, h * 0.2);
            });

            // Top Side: .in Tech
            const inTexture = createTexture((ctx, w, h) => {
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 8;

                // Circuit lines
                ctx.beginPath();
                ctx.moveTo(50, 50);
                ctx.lineTo(50, 200);
                ctx.lineTo(300, 200);
                ctx.lineTo(300, 100);
                ctx.moveTo(w-50, h-50);
                ctx.lineTo(w-50, h-300);
                ctx.lineTo(150, h-300);
                ctx.lineTo(150, h-100);
                ctx.stroke();

                // Nodes
                ctx.fillStyle = '#00aaff';
                ctx.beginPath();
                ctx.arc(50, 50, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(300, 100, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(150, h-100, 15, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 160px Orbitron';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('.in', w / 2, h / 2);
            });
            
            // Generic texture for other sides
            const genericTexture = createTexture((ctx, w, h) => {
                ctx.fillStyle = '#222222';
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 20;
                ctx.strokeRect(0,0,w,h);
            });


            // --- Cube Creation ---
            const materials = [
                sdTexture,      // Right side
                sdTexture,      // Left side
                inTexture,      // Top side
                inTexture,      // Bottom side
                vmTexture,      // Front side
                vmTexture,      // Back side
            ];
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            cube = new THREE.Mesh(geometry, materials.map(tex => new THREE.MeshStandardMaterial({ map: tex })));
            scene.add(cube);

            // --- Controls ---
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;

            // Disable zoom and pan
            controls.enableZoom = false;
            controls.enablePan = false;

            // Limit rotation to a slight twist - REMOVED
            /* const angleLimit = Math.PI / 4; // 45 degrees
            controls.minAzimuthAngle = -angleLimit;
            controls.maxAzimuthAngle = angleLimit;
            controls.minPolarAngle = Math.PI / 2 - angleLimit;
            controls.maxPolarAngle = Math.PI / 2 + angleLimit; */
            
            // Set initial rotation
            cube.rotation.y = -0.4;
            cube.rotation.x = -0.4;

        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // only required if controls.enableDamping or controls.autoRotate are set to true
            renderer.render(scene, camera);
        }

        // --- Handle Window Resize ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize, false);

        // --- Start the application ---
        init();
        animate();

    </script>
</body>
</html>
